---
title: An Extension to std::array
excerpt: Extending std::array a little bit
categories: [Blog]
tags: [c++, container, array]
---

The addition of `std::array` is nice!
But when I was experimenting with it to be a replacement for `string` as an alternative container of a sequence of characters, I encountered a little missing functionality.
A `string` can be instantiated by passing a `const char *` and a `size_type` but `array` has no similar constructor.

~~~ cpp
string s("Hello", 5);
~~~

Here is the experimental character container that I was playing with.

~~~ cpp
class char_data
{
private:
    std::tr1::array<char, 100> content;
    std::size_t count;
public:
    char_data() : count(0) { }
    char_data(const char *s) : count(std::strlen(s)) {
    	memcpy(content.data(), s, count);
    }
    char_data(const std::string &s) : count(s.length()) {
        memcpy(content.data(), s.data(), count);
    }
};
~~~

It would be nice if I could initialize the array in the *member initializer list*&nbsp; like i could with `string`.
That way, the array will not have to be default initialized with *some*&nbsp; character before the body of the constructor which I would then overwrite in the body of the constructor.

~~~ cpp
template<class T, size_t N>
array<T, N>::array(const T *t, size_t n, bool contiguous = false) {
    if (contiguous) {
        memcpy(content.data(), t, n);
    } else {
        std::copy(std::begin(t), std::end(t), content.data());
    }
}
~~~

The psuedo implementation above has not been tested but only shows how it might be implemented for the use case above.
